<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ponia Demo — LI.FI test</title>
<style>
  :root {
    --bg: #0f0f10;
    --card: #111213;
    --muted: #9aa0a6;
    --accent: #FFD73F;
    --text: #ffffff;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  body { background: var(--bg); color:var(--text); margin:0; padding:20px; }
  .container { max-width:980px; margin:20px auto; }
  h1 { text-align:center; margin-bottom:8px; }
  .card { background:var(--card); padding:20px; border-radius:10px; box-shadow:0 6px 20px rgba(0,0,0,.6); }
  label { display:block; color:var(--muted); margin-top:12px; font-size:13px; }
  select,input { width:100%; padding:10px 12px; margin-top:6px; border-radius:8px; border:1px solid rgba(255,255,255,.04); background:#0b0b0c; color:var(--text); }
  .row { display:flex; gap:16px; }
  .col { flex:1; }
  button { background:var(--accent); border:none; padding:10px 16px; border-radius:10px; cursor:pointer; color:#111; font-weight:700; }
  .muted { color:var(--muted); font-size:13px; }
  pre { background:#080808; padding:12px; border-radius:8px; overflow:auto; color:#ffd; }
  .controls { margin-top:14px; display:flex; gap:10px; flex-wrap:wrap; }
  .status { margin-top:12px; color:var(--muted); font-size:13px; }
  footer { text-align:center; margin-top:18px; color:var(--muted); font-size:13px; }
</style>
</head>
<body>
  <div class="container">
    <h1>Ponia Demo — LI.FI (quote test)</h1>

    <div class="card">
      <div class="muted">Platform chain (détectée automatiquement si possible)</div>
      <input id="platformChain" placeholder="Ex: polygon" />

      <label>From chain</label>
      <select id="fromChain">
        <option value="ethereum">Ethereum</option>
        <option value="polygon">Polygon</option>
        <option value="bsc">BNB Chain</option>
        <option value="solana">Solana</option>
        <option value="arbitrum">Arbitrum</option>
      </select>

      <div class="row" style="margin-top:10px">
        <div class="col">
          <label>From amount (en unité lisible, ex. 0.1)</label>
          <input id="amount" value="0.01" />
        </div>
        <div class="col">
          <label>To chain (platform)</label>
          <select id="toChain">
            <option value="polygon">Polygon</option>
            <option value="ethereum">Ethereum</option>
            <option value="bsc">BNB Chain</option>
            <option value="solana">Solana</option>
          </select>
        </div>
      </div>

      <div class="controls">
        <button id="btnConnect">Connect Wallet</button>
        <button id="btnGetQuote">Get Quote</button>
        <button id="btnExecute">(Optional) Execute Route</button>
      </div>

      <div class="status" id="status">Status: ready</div>

      <div style="margin-top:14px">
        <div class="muted">Quote / Route JSON</div>
        <pre id="output">Logs will appear here</pre>
      </div>
    </div>

    <footer>Test only — Demo Ponia / LI.FI. Use Phantom for Solana, MetaMask for EVM chains.</footer>
  </div>

<script>
const statusEl = document.getElementById('status');
const out = document.getElementById('output');
const btnConnect = document.getElementById('btnConnect');
const btnGetQuote = document.getElementById('btnGetQuote');
const btnExecute = document.getElementById('btnExecute');
const platformInput = document.getElementById('platformChain');

let walletType = null;
let evmAddress = null;
let solanaProvider = null;
let phantomAddress = null;
let lastQuote = null;

function log(...args){
  console.log(...args);
  out.textContent = args.map(a => typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a)).join(' ');
}

function toSmallestUnit(chain, readableAmount){
  if(!readableAmount) return "0";

  const ra = String(readableAmount).trim();
  if(chain === 'solana'){
    const parts = ra.split('.');
    const whole = BigInt(parts[0] || 0);
    const frac = parts[1] || '';
    const fracPadded = (frac + '0'.repeat(9)).slice(0,9);
    const val = whole * BigInt(1_000_000_000) + BigInt(fracPadded || '0');
    return val.toString();
  } else {
    const parts = ra.split('.');
    const whole = BigInt(parts[0] || 0);
    const frac = parts[1] || '';
    const fracPadded = (frac + '0'.repeat(18)).slice(0,18);
    const val = whole * BigInt("1000000000000000000") + BigInt(fracPadded || '0');
    return val.toString();
  }
}

function getChainId(chainName){
  const chainMap = {
    'ethereum': 1,
    'polygon': 137,
    'bsc': 56,
    'arbitrum': 42161,
    'solana': 'SOL'
  };
  return chainMap[chainName] || chainName;
}

function nativeTokenForChain(chain){
  if(chain === 'solana') return 'So11111111111111111111111111111111111111112';
  return '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
}

function autoDetectPlatform(){
  const url = new URL(location.href);
  const chainParam = url.searchParams.get('chain');
  if(chainParam){ platformInput.value = chainParam; return; }
}

async function connectMetaMask(){
  if(!window.ethereum) throw new Error('MetaMask not found');
  const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
  if(accounts && accounts[0]){
    evmAddress = accounts[0];
    walletType = 'metamask';
    statusEl.textContent = 'Connected MetaMask: ' + evmAddress;
    log('EVM address', evmAddress);
    return evmAddress;
  } else throw new Error('No account returned');
}

async function connectPhantom(){
  if(window.solana && window.solana.isPhantom){
    solanaProvider = window.solana;
    const res = await solanaProvider.connect();
    phantomAddress = solanaProvider.publicKey.toString();
    walletType = 'phantom';
    statusEl.textContent = 'Connected Phantom: ' + phantomAddress;
    log('Phantom address', phantomAddress);
    return phantomAddress;
  } else {
    throw new Error('Phantom not detected in window.solana');
  }
}

btnConnect.addEventListener('click', async () => {
  try{
    const fromChain = document.getElementById('fromChain').value;
    statusEl.textContent = 'Connecting...';
    if(fromChain === 'solana'){
      await connectPhantom();
    } else {
      await connectMetaMask();
    }
  } catch(e){
    statusEl.textContent = 'Connect failed: ' + (e.message || e);
    log('connect error', e);
  }
});

btnGetQuote.addEventListener('click', async () => {
  try{
    statusEl.textContent = 'Building quote...';
    const fromChain = document.getElementById('fromChain').value;
    const toChain = document.getElementById('toChain').value;
    const readableAmount = document.getElementById('amount').value;

    if(fromChain === 'solana'){
      if(!phantomAddress){
        if(window.solana && window.solana.isPhantom){
          try { await connectPhantom(); } catch(e){ }
        }
      }
    } else {
      if(!evmAddress){
        if(window.ethereum){
          try { await connectMetaMask(); } catch(e){ }
        }
      }
    }

    let fromAddress;
    if(walletType === 'phantom' && phantomAddress){
      fromAddress = phantomAddress;
    } else if(walletType === 'metamask' && evmAddress){
      fromAddress = evmAddress;
    } else {
      throw new Error('Wallet not connected. Click Connect Wallet first and accept.');
    }

    const fromAmount = toSmallestUnit(fromChain, readableAmount);

    const fromToken = nativeTokenForChain(fromChain);
    const toToken = nativeTokenForChain(toChain);

    const fromChainId = getChainId(fromChain);
    const toChainId = getChainId(toChain);

    const base = 'https://li.quest/v1/quote';
    const params = new URLSearchParams({
      fromChain: fromChainId,
      toChain: toChainId,
      fromToken: fromToken,
      toToken: toToken,
      fromAmount: fromAmount,
      fromAddress: fromAddress
    });

    const url = base + '?' + params.toString();

    statusEl.textContent = 'Fetching quote from LI.FI...';
    log('fetching quote url', url);

    const r = await fetch(url);
    if(!r.ok){
      const txt = await r.text();
      throw new Error('LI.FI error ' + r.status + ': ' + txt);
    }
    const json = await r.json();
    lastQuote = json;
    statusEl.textContent = 'Quote fetched (see output).';
    log(json);
    out.textContent = JSON.stringify(json, null, 2);

  } catch(err){
    statusEl.textContent = 'Quote failed: ' + (err.message || err);
    log('quote failed', err);
  }
});

btnExecute.addEventListener('click', async () => {
  try{
    if(!lastQuote) throw new Error('No quote in memory. Get quote first.');
    statusEl.textContent = 'Preparing to execute route (demo)...';

    let found = null;
    for(const step of lastQuote.steps || []){
      if(step.calls && step.calls.length){
        for(const call of step.calls){
          if(call.to && call.data && call.value !== undefined){
            found = { step, call };
            break;
          }
        }
      }
      if(found) break;
    }

    if(!found){
      statusEl.textContent = 'No simple EVM tx found — use LI.FI widget/SDK to execute full route.';
      log('execute: route details', lastQuote);
      return;
    }

    if(walletType !== 'metamask' || !evmAddress){
      throw new Error('Detected EVM transaction but MetaMask not connected.');
    }

    const call = found.call;
    const tx = {
      to: call.to,
      data: call.data,
      value: call.value ? '0x' + BigInt(call.value).toString(16) : '0x0',
    };

    statusEl.textContent = 'Sending transaction via MetaMask...';
    const txHash = await window.ethereum.request({ method: 'eth_sendTransaction', params: [tx] });
    statusEl.textContent = 'Transaction submitted: ' + txHash;
    log('txHash', txHash);

  } catch(e){
    statusEl.textContent = 'Execute failed: ' + (e.message || e);
    log('execute error', e);
  }
});

autoDetectPlatform();

(function detectWalletsOnLoad(){
  let info = 'Ready.';
  if(window.ethereum) info += ' MetaMask available.';
  if(window.solana && window.solana.isPhantom) info += ' Phantom available.';
  statusEl.textContent = info;
  log('wallet detect', { metamask: !!window.ethereum, phantom: !!(window.solana && window.solana.isPhantom) });
})();
</script>
</body>
</html>
