Parfait — on passe à l’étape suivante : connexion multi-wallet + récupérer un quote LI.FI + exécuter la route.
Je te donne une solution complète, prête à coller dans un projet Replit (HTML + JS). Elle couvre les wallets principaux (MetaMask / Coinbase / any injected EVM, WalletConnect, Phantom pour Solana). Le code est un squelette fonctionnel — il faudra l’adapter/compléter côté production (sécurité, UX, gestion d’erreurs, logs, tests sur testnets).

Architecture / flux résumé
	1.	Détecter la blockchain « native » de la dApp (ex : polygon) — possibilité d’override via openPonia({ chain: 'polygon' }).
	2.	L’utilisateur connecte son wallet (EVM : MetaMask/WalletConnect/Coinbase ; Solana : Phantom).
	3.	L’app demande un quote à LI.FI (https://li.quest/v1/quote) avec fromChain, toChain, fromToken, toToken, fromAmount (aucune clé nécessaire côté client pour widget).
	4.	LI.FI renvoie une route (liste d’étapes). Pour les steps « transaction » on prépare tx et on appelle le wallet pour signer / envoyer.
	5.	On suit l’avancement, on affiche la progression et le résultat.

Important : en production, pour des limites/monitoring tu peux utiliser une API key LI.FI côté serveur. Ne jamais exposer de secret client-side.

⸻

Dépendances (CDN pour Replit / page statique)

Dans ton index.html ajoute ces scripts (CDN) :

<!-- ethers pour EVM -->
<script src="https://cdn.jsdelivr.net/npm/ethers@6.8.0/dist/ethers.min.js"></script>

<!-- WalletConnect v1 provider (simple à intégrer) -->
<script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>

<!-- Solana web3 + phantom detection -->
<script src="https://unpkg.com/@solana/web3.js@1.78.0/lib/index.iife.js"></script>

Si tu veux Web3Modal moderne, on peut l’ajouter — mais ici je fournis des connecteurs simples.

⸻

HTML minimal de la page (UI demo)

Colle ceci dans ton index.html :

<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ponia Widget Demo</title>
  <style>
    body{background:#0f0f10;color:#fff;font-family:Inter,system-ui,Arial; padding:20px;}
    .btn{background:#ffd73f;color:#000;padding:10px 18px;border-radius:10px;border:none;cursor:pointer}
    .card{background:#111;padding:18px;border-radius:12px;max-width:900px;margin:20px auto}
    input, select{padding:10px;border-radius:8px;border:1px solid #222;background:#0b0b0c;color:#fff;width:100%}
    pre{background:#0b0b0c;padding:12px;border-radius:8px;overflow:auto;color:#ffd73f}
  </style>
</head>
<body>
  <div class="card">
    <h2>Ponia Demo — widget LI.FI</h2>

    <div>
      <label>Platform chain (détectée)</label>
      <input id="platformChain" placeholder="ex: polygon" value="polygon" />
    </div>

    <div style="margin-top:12px">
      <label>From chain</label>
      <select id="fromChain">
        <option value="ethereum">Ethereum</option>
        <option value="bsc">BNB Chain</option>
        <option value="polygon">Polygon</option>
        <option value="solana">Solana</option>
      </select>
    </div>

    <div style="margin-top:12px">
      <label>To chain (platform)</label>
      <select id="toChain">
        <option value="polygon">Polygon</option>
        <option value="ethereum">Ethereum</option>
        <option value="solana">Solana</option>
      </select>
    </div>

    <div style="margin-top:12px;display:flex;gap:8px">
      <button class="btn" id="connectBtn">Connect Wallet</button>
      <button class="btn" id="getQuoteBtn">Get Quote</button>
      <button class="btn" id="executeBtn">Execute Route</button>
    </div>

    <p id="status" style="margin-top:12px;color:#ddd"></p>

    <pre id="output">Logs will appear here</pre>
  </div>

  <script src="app.js"></script>
</body>
</html>


⸻

app.js — logique complète (squelette, à coller tel quel)

Ce fichier contient la logique : connexion wallet, fetch quote, exécution simple des steps EVM & Solana.
Colle ce qui suit dans app.js :

// app.js - demo widget integration LI.FI + wallets (EVM + Solana Phantom + WalletConnect)
// nécessite : ethers (CDN), WalletConnect provider (CDN), @solana/web3.js (CDN)

const statusEl = document.getElementById('status');
const outputEl = document.getElementById('output');

let providerEVM = null;   // ethers provider
let signer = null;
let walletType = null; // 'injected' | 'walletconnect' | 'phantom'
let solanaProvider = null; // phantom provider for solana
let lastQuote = null; // store LI.FI quote

function log(...args){
  console.log(...args);
  outputEl.textContent = (outputEl.textContent + '\n' + args.map(a => typeof a === 'object' ? JSON.stringify(a,null,2) : String(a)).join(' ')).slice(-20000);
}
function setStatus(s){ statusEl.textContent = s; log('[status]', s); }

// --- Wallet connect functions for EVM / WalletConnect / Solana ---

async function connectInjectedEVM(){
  if(window.ethereum){
    try{
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      providerEVM = new ethers.BrowserProvider(window.ethereum);
      signer = await providerEVM.getSigner();
      walletType = 'injected';
      const addr = await signer.getAddress();
      setStatus('Connected (injected) ' + addr);
      log('connected injected', addr);
      return addr;
    }catch(e){ setStatus('User rejected'); throw e; }
  } else {
    throw new Error('No injected wallet found');
  }
}

async function connectWalletConnect(){
  // using legacy WalletConnect provider for demo simplicity
  const WalletConnectProvider = window.WalletConnectProvider.default;
  const wcProvider = new WalletConnectProvider({
    rpc: {
      // add RPC endpoints per chain id used. Example:
      1: "https://rpc.ankr.com/eth",
      137: "https://rpc.ankr.com/polygon",
      56: "https://bsc-dataseed.binance.org/",
    },
  });
  await wcProvider.enable();
  providerEVM = new ethers.BrowserProvider(wcProvider);
  signer = await providerEVM.getSigner();
  walletType = 'walletconnect';
  const addr = await signer.getAddress();
  setStatus('Connected (WalletConnect) ' + addr);
  log('wc connected', addr);
  return addr;
}

async function connectPhantom(){
  if(window.solana && window.solana.isPhantom){
    solanaProvider = window.solana;
    await solanaProvider.connect();
    walletType = 'phantom';
    setStatus('Connected Phantom ' + solanaProvider.publicKey.toString());
    log('phantom connected', solanaProvider.publicKey.toString());
    return solanaProvider.publicKey.toString();
  } else {
    throw new Error('Phantom not found');
  }
}

// determines best connector by platform chain (EVM vs Solana) or user choice
async function connectAny(preferred){
  // preferred = 'injected' | 'walletconnect' | 'phantom' | undefined
  try{
    if(preferred === 'phantom'){
      return await connectPhantom();
    }
    // try injected first
    if(window.ethereum && (preferred === 'injected' || !preferred)){
      return await connectInjectedEVM();
    }
    // fallback walletconnect
    return await connectWalletConnect();
  } catch(e){
    log('connect error', e);
    throw e;
  }
}

// --- LI.FI quote request ---
// docs: https://li.quest/ (we call /v1/quote)
async function getQuoteFromLIFI(params){
  // params: { fromChain, toChain, fromToken, toToken, fromAmount }
  // LI.FI expects chain NAMES (like 'ethereum', 'polygon', 'solana') and token addresses. For native chains, tokens can be 'native'.
  const query = new URLSearchParams(params).toString();
  const url = `https://li.quest/v1/quote?${query}`;
  setStatus('Fetching quote from LI.FI...');
  const r = await fetch(url);
  if(!r.ok){
    const text = await r.text();
    throw new Error('LI.FI error ' + r.status + ' ' + text);
  }
  const data = await r.json();
  lastQuote = data;
  setStatus('Quote received');
  log('quote', data);
  return data;
}

// --- Execute route (basic) ---
// This is an example flow. LI.FI returns a route with steps. Each step may contain tx data for EVM or solana.
// We'll focus on typical EVM flows (approve + tx) and Solana sendRawTransaction flow for solana steps.
async function executeRoute(route){
  if(!route) throw new Error('No route supplied');
  setStatus('Executing route, steps: ' + (route.steps?.length || 0));

  for(let i=0;i<route.steps.length;i++){
    const step = route.steps[i];
    log('step', i, step);
    // EVM transaction step
    if(step.action && step.action.fromType === 'EVM' || step.chain?.toLowerCase && ['ethereum','polygon','bsc','arbitrum','optimism'].includes(String(step.chain).toLowerCase())){
      // step.tx contains { to, data, value, gasLimit, ... }
      const tx = step.tx;
      if(!tx){
        log('no tx in step (maybe native bridging or external). skipping.');
        continue;
      }
      // Ensure we have signer
      if(!signer){
        throw new Error('No EVM signer connected');
      }
      // Create Ethers tx
      const txReq = {
        to: tx.to,
        data: tx.data || '0x',
        value: tx.value ? ethers.BigInt(tx.value) : undefined,
        gasLimit: tx.gasLimit ? ethers.BigInt(tx.gasLimit) : undefined,
      };
      setStatus(`Sending tx on ${step.chain} -> ${txReq.to}`);
      log('sending evm tx', txReq);
      // If chain differs from current provider chain, user must switch network; or we instantiate JSON-RPC for that chain (omitted here).
      const txResponse = await signer.sendTransaction(txReq);
      log('txResponse', txResponse);
      setStatus('Tx sent: ' + txResponse.hash);
      await txResponse.wait();
      log('tx mined', txResponse.hash);
    } else if(step.chain && String(step.chain).toLowerCase() === 'solana'){
      // Solana step: step.transaction (base64) or step.tx
      if(!solanaProvider) throw new Error('No Solana wallet connected');
      const raw = step.transaction; // LI.FI may provide base64 tx
      if(!raw){
        log('no solana tx in step, skipping');
        continue;
      }
      // sign & send
      const txBytes = Buffer.from(raw, 'base64');
      const { Connection, Transaction } = solanaWeb3;
      // sign & send via phantom - phantom typically expects a Transaction object, but LI.FI may give a serialized tx
      const resp = await solanaProvider.signAndSendTransaction({ serializedTransaction: txBytes });
      log('solana resp', resp);
    } else {
      log('Unknown step kind, skipping', step);
    }
  }

  setStatus('Route execution finished');
}

// --- UI handlers ---
document.getElementById('connectBtn').addEventListener('click', async ()=>{
  try{
    // simple prompt to choose wallet (for demo)
    const choice = prompt('connect with: injected | walletconnect | phantom (type one)');
    await connectAny(choice || undefined);
  } catch(err){
    log('connect error', err.message || err);
    setStatus('connect failed: ' + (err.message || err));
  }
});

document.getElementById('getQuoteBtn').addEventListener('click', async ()=>{
  try{
    const fromChain = document.getElementById('fromChain').value;
    const toChain   = document.getElementById('toChain').value;
    // simple: request native token swap (from native to native)
    // LI.FI requires token addresses; for native we use token=0xeeee... or 'native' - in practice LI.FI expects tokenAddress or token param; use 'native' for demo on solana? We'll request from native on EVM.
    const amount = (document.querySelector('input#amount') && document.querySelector('input#amount').value) || '100000000000000000'; // 0.1 ETH in wei as fallback
    // For clarity we will ask for fromToken = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' (LI.FI accepts native token shorthand)
    const query = {
      fromChain: fromChain,
      toChain: toChain,
      fromToken: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
      toToken: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',
      fromAmount: amount
    };
    const quote = await getQuoteFromLIFI(query);
    log('best route', quote);
    alert('Quote received; see logs');
  } catch(e){
    log('quote error', e);
    setStatus('Quote failed: ' + (e.message || e));
  }
});

document.getElementById('executeBtn').addEventListener('click', async ()=>{
  try{
    if(!lastQuote) throw new Error('No quote in memory. Get quote first.');
    // For demo: pick best route
    const route = lastQuote.route || lastQuote.routes?.[0] || lastQuote;
    if(!route) throw new Error('No route found in quote');
    await executeRoute(route);
    alert('Execution done. Check logs');
  } catch(e){
    log('execute error', e);
    setStatus('Execution failed: ' + (e.message || e));
  }
});


