Parfait — je vais tout te donner dans un seul coup : la page HTML complète (style + JS) qui corrige les erreurs que tu avais (notamment fromAddress manquant), détecte automatiquement Phantom (Solana) et MetaMask (EVM), convertit correctement les montants selon la chaîne, demande un quote à LI.FI et affiche la route retournée.
Je t’explique aussi les étapes suivantes (exécution du route) et comment tester pas-à-pas.

Important : ce code ne signe pas automatiquement les transactions cross-chain pour toi (l’exécution complète d’un route LI.FI peut nécessiter leur Widget ou le SDK côté client/serveur). Ici on s’assure d’avoir un quote valide et toutes les données nécessaires pour exécuter ensuite la route via le widget/SDK.
Tu peux utiliser ce code directement dans ton Replit.

⸻

1) Fichier à copier-coller (index.html)

Crée un projet web statique (HTML/CSS/JS). Copie ce fichier index.html (tout dans un seul fichier pour la simplicité).

<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ponia Demo — LI.FI test</title>
<style>
  :root {
    --bg: #0f0f10;
    --card: #111213;
    --muted: #9aa0a6;
    --accent: #FFD73F;
    --text: #ffffff;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  body { background: var(--bg); color:var(--text); margin:0; padding:20px; }
  .container { max-width:980px; margin:20px auto; }
  h1 { text-align:center; margin-bottom:8px; }
  .card { background:var(--card); padding:20px; border-radius:10px; box-shadow:0 6px 20px rgba(0,0,0,.6); }
  label { display:block; color:var(--muted); margin-top:12px; font-size:13px; }
  select,input { width:100%; padding:10px 12px; margin-top:6px; border-radius:8px; border:1px solid rgba(255,255,255,.04); background:#0b0b0c; color:var(--text); }
  .row { display:flex; gap:16px; }
  .col { flex:1; }
  button { background:var(--accent); border:none; padding:10px 16px; border-radius:10px; cursor:pointer; color:#111; font-weight:700; }
  .muted { color:var(--muted); font-size:13px; }
  pre { background:#080808; padding:12px; border-radius:8px; overflow:auto; color:#ffd; }
  .controls { margin-top:14px; display:flex; gap:10px; flex-wrap:wrap; }
  .status { margin-top:12px; color:var(--muted); font-size:13px; }
  footer { text-align:center; margin-top:18px; color:var(--muted); font-size:13px; }
</style>
</head>
<body>
  <div class="container">
    <h1>Ponia Demo — LI.FI (quote test)</h1>

    <div class="card">
      <div class="muted">Platform chain (détectée automatiquement si possible)</div>
      <input id="platformChain" placeholder="Ex: polygon" />

      <label>From chain</label>
      <select id="fromChain">
        <option value="ethereum">Ethereum</option>
        <option value="polygon">Polygon</option>
        <option value="bsc">BNB Chain</option>
        <option value="solana">Solana</option>
        <option value="arbitrum">Arbitrum</option>
      </select>

      <div class="row" style="margin-top:10px">
        <div class="col">
          <label>From amount (en unité lisible, ex. 0.1)</label>
          <input id="amount" value="0.01" />
        </div>
        <div class="col">
          <label>To chain (platform)</label>
          <select id="toChain">
            <option value="polygon">Polygon</option>
            <option value="ethereum">Ethereum</option>
            <option value="bsc">BNB Chain</option>
            <option value="solana">Solana</option>
          </select>
        </div>
      </div>

      <div class="controls">
        <button id="btnConnect">Connect Wallet</button>
        <button id="btnGetQuote">Get Quote</button>
        <button id="btnExecute">(Optional) Execute Route</button>
      </div>

      <div class="status" id="status">Status: ready</div>

      <div style="margin-top:14px">
        <div class="muted">Quote / Route JSON</div>
        <pre id="output">Logs will appear here</pre>
      </div>
    </div>

    <footer>Test only — Demo Ponia / LI.FI. Use Phantom for Solana, MetaMask for EVM chains.</footer>
  </div>

<script>
/*
  Demo JS:
  - detect wallets (MetaMask / Phantom)
  - build LI.FI quote query with required fromAddress
  - convert user amount to smallest unit depending on chain
  - fetch quote and show results
  - NOTE: executing a full cross-chain route is not done automatically here.
*/

const statusEl = document.getElementById('status');
const out = document.getElementById('output');
const btnConnect = document.getElementById('btnConnect');
const btnGetQuote = document.getElementById('btnGetQuote');
const btnExecute = document.getElementById('btnExecute');
const platformInput = document.getElementById('platformChain');

let walletType = null;        // 'metamask' | 'phantom' | null
let evmAddress = null;        // 0x...
let solanaProvider = null;    // window.solana
let phantomAddress = null;    // base58 address
let lastQuote = null;

function log(...args){
  console.log(...args);
  out.textContent = args.map(a => typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a)).join(' ');
}

// small helper: convert human amount to smallest unit (string)
function toSmallestUnit(chain, readableAmount){
  // readableAmount is string like "0.01"
  if(!readableAmount) return "0";

  // Use BigInt for integer math
  const ra = String(readableAmount).trim();
  if(chain === 'solana'){
    // SOL decimals = 9 -> lamports
    // lamports = amount * 1e9
    const parts = ra.split('.');
    const whole = BigInt(parts[0] || 0);
    const frac = parts[1] || '';
    const fracPadded = (frac + '0'.repeat(9)).slice(0,9);
    const val = whole * BigInt(1_000_000_000) + BigInt(fracPadded || '0');
    return val.toString();
  } else {
    // assume EVM-like chain with 18 decimals
    const parts = ra.split('.');
    const whole = BigInt(parts[0] || 0);
    const frac = parts[1] || '';
    const fracPadded = (frac + '0'.repeat(18)).slice(0,18);
    const val = whole * BigInt("1000000000000000000") + BigInt(fracPadded || '0');
    return val.toString();
  }
}

// map default fromToken for chain (native)
function nativeTokenForChain(chain){
  if(chain === 'solana') return 'So11111111111111111111111111111111111111112'; // wrapped SOL token (commonly used)
  // EVM native placeholder:
  return '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
}

// try detect platform chain from URL or from input
function autoDetectPlatform(){
  // example: ?chain=polygon in URL
  const url = new URL(location.href);
  const chainParam = url.searchParams.get('chain');
  if(chainParam){ platformInput.value = chainParam; return; }

  // else leave empty for manual input
}

// connect functions
async function connectMetaMask(){
  if(!window.ethereum) throw new Error('MetaMask not found');
  // request accounts
  const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
  if(accounts && accounts[0]){
    evmAddress = accounts[0];
    walletType = 'metamask';
    statusEl.textContent = 'Connected MetaMask: ' + evmAddress;
    log('EVM address', evmAddress);
    return evmAddress;
  } else throw new Error('No account returned');
}

async function connectPhantom(){
  if(window.solana && window.solana.isPhantom){
    solanaProvider = window.solana;
    // request connect
    const res = await solanaProvider.connect(); // will open modal in phantom
    phantomAddress = solanaProvider.publicKey.toString();
    walletType = 'phantom';
    statusEl.textContent = 'Connected Phantom: ' + phantomAddress;
    log('Phantom address', phantomAddress);
    return phantomAddress;
  } else {
    throw new Error('Phantom not detected in window.solana');
  }
}

// unified connect button
btnConnect.addEventListener('click', async () => {
  try{
    // choose connect depending on selected fromChain
    const fromChain = document.getElementById('fromChain').value;
    statusEl.textContent = 'Connecting...';
    if(fromChain === 'solana'){
      await connectPhantom();
    } else {
      await connectMetaMask();
    }
  } catch(e){
    statusEl.textContent = 'Connect failed: ' + (e.message || e);
    log('connect error', e);
  }
});

// Get quote button
btnGetQuote.addEventListener('click', async () => {
  try{
    statusEl.textContent = 'Building quote...';
    // ensure we have fromAddress
    const fromChain = document.getElementById('fromChain').value;
    const toChain = document.getElementById('toChain').value;
    const readableAmount = document.getElementById('amount').value;

    // if not connected, attempt to auto connect minimal
    if(fromChain === 'solana'){
      if(!phantomAddress){
        // try to connect Phantom silently
        if(window.solana && window.solana.isPhantom){
          try { await connectPhantom(); } catch(e){ /* user may reject */ }
        }
      }
    } else {
      if(!evmAddress){
        if(window.ethereum){
          try { await connectMetaMask(); } catch(e){ /* user may reject */ }
        }
      }
    }

    // Build fromAddress
    let fromAddress;
    if(walletType === 'phantom' && phantomAddress){
      fromAddress = phantomAddress;
    } else if(walletType === 'metamask' && evmAddress){
      fromAddress = evmAddress;
    } else {
      // no wallet connected: show error and stop
      throw new Error('Wallet not connected. Click Connect Wallet first and accept.');
    }

    // convert amount to smallest unit
    const fromAmount = toSmallestUnit(fromChain, readableAmount);

    // choose fromToken and toToken defaults
    const fromToken = nativeTokenForChain(fromChain);
    const toToken = nativeTokenForChain(toChain);

    // Construct LI.FI quote URL
    // Note: li.quest/v1/quote is the documented endpoint
    const base = 'https://li.quest/v1/quote';
    const params = new URLSearchParams({
      fromChain: fromChain,
      toChain: toChain,
      fromToken: fromToken,
      toToken: toToken,
      fromAmount: fromAmount,
      fromAddress: fromAddress
    });

    const url = base + '?' + params.toString();

    statusEl.textContent = 'Fetching quote from LI.FI...';
    log('fetching quote url', url);

    const r = await fetch(url);
    if(!r.ok){
      const txt = await r.text();
      throw new Error('LI.FI error ' + r.status + ': ' + txt);
    }
    const json = await r.json();
    lastQuote = json;
    statusEl.textContent = 'Quote fetched (see output).';
    log(json);
    out.textContent = JSON.stringify(json, null, 2);

  } catch(err){
    statusEl.textContent = 'Quote failed: ' + (err.message || err);
    log('quote failed', err);
  }
});

// Execute route (demo)
btnExecute.addEventListener('click', async () => {
  // WARNING: executing a cross-chain route fully is non-trivial.
  // Here we provide a minimal demo: if LI.FI returns a single step EVM transaction
  // we show how to send it using window.ethereum. For Solana steps you'd need to
  // use phantom.signTransaction etc. Best path for full integration is to use
  // LI.FI widget or SDK in production.
  try{
    if(!lastQuote) throw new Error('No quote in memory. Get quote first.');
    statusEl.textContent = 'Preparing to execute route (demo)...';

    // Find an onChain transaction step in the route
    // LI.FI route structure: route.steps[*].transactions[*] ...
    // We'll scan for a step with a 'transactionRequest' or 'txRequest' for EVM.
    let found = null;
    for(const step of lastQuote.steps || []){
      if(step.calls && step.calls.length){
        // some steps include calls (EVM)
        for(const call of step.calls){
          if(call.to && call.data && call.value !== undefined){
            found = { step, call };
            break;
          }
        }
      }
      if(found) break;
    }

    if(!found){
      // fallback: just display the route and tell user to use LI.FI widget / SDK
      statusEl.textContent = 'No simple EVM tx found — use LI.FI widget/SDK to execute full route.';
      log('execute: route details', lastQuote);
      return;
    }

    // If we have an EVM call and user has MetaMask connected -> sendTransaction
    if(walletType !== 'metamask' || !evmAddress){
      throw new Error('Detected EVM transaction but MetaMask not connected.');
    }

    const call = found.call;
    // Prepare tx for metamask
    const tx = {
      to: call.to,
      data: call.data,
      value: call.value ? '0x' + BigInt(call.value).toString(16) : '0x0',
      // chainId may be required by MetaMask, but omitted here for simplicity
    };

    statusEl.textContent = 'Sending transaction via MetaMask...';
    const txHash = await window.ethereum.request({ method: 'eth_sendTransaction', params: [tx] });
    statusEl.textContent = 'Transaction submitted: ' + txHash;
    log('txHash', txHash);

  } catch(e){
    statusEl.textContent = 'Execute failed: ' + (e.message || e);
    log('execute error', e);
  }
});

// auto detect platform chain
autoDetectPlatform();

// convenience: detect and show if Phantom/MetaMask available
(function detectWalletsOnLoad(){
  let info = 'Ready.';
  if(window.ethereum) info += ' MetaMask available.';
  if(window.solana && window.solana.isPhantom) info += ' Phantom available.';
  statusEl.textContent = info;
  log('wallet detect', { metamask: !!window.ethereum, phantom: !!(window.solana && window.solana.isPhantom) });
})();
</script>
</body>
</html>



